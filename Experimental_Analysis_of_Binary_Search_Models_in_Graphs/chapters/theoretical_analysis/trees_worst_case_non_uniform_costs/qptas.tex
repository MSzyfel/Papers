
\SetKwFunction{FBuildDT}{BuildDT}
\SetKwFunction{FDPTimelinesCosts}{DPTimelinesCosts}
\subsection{QPTAS for the $T||V,c||C_{max}$ problem}

The following algorithh is a simplified version of the QPTAS provided in \cite{dereniowski2017ApproxSsForGeneralBSinWTs}. The core idea of the algorithm is the same, however, our solution uses the language of decision trees instead of the language of sequence assignments, which makes the algorithm more intuitive.

For the rest of the analysis, without loss of the generality, we will assume that $T$ is rooted in a vertex $v$ minimizing $c\br{v}$.  We will also assume that all costs are normalized, so that $\max_{v\in V\br{T}}\brc{c\br{v}}=1$. If not, the costs are scaled by dividing them by $\max_{v\in V\br{T}}\brc{c(v)}$. Note that this operation does not affect the optimality of a strategy or the quality of an approximation.
\begin{observation}\label{basicBoundsOnCost}
    Let $T$ be a tree such that $\spr{V\br{T}}> 1$ and $c:V\to \mathbb{R}^+$ be a normalized weight function. Then, $1\leq \OPT(T) \leq \fl{\log n}+1$.
    \begin{proof}
        The first inequality is due to the fact that there exists $v\in V\br{T}$, such that $c\br{v}=1$ and for any decision tree $D$ we have $v\in Q_{D}\br{T,v}$. The second inequality is due to the fact that we can always locate the target using $\fl{\log n}+1$ queries \cite{OnakParys2006GenOfBSSInTsAndFLikePosets}.
    \end{proof}
\end{observation}
\subsubsection{Rounding}
We will use the following rounding schem which will allow us to discretise the space of possible solutions to process it efficiently. Let $p \in\mathbb{N}$, and $k=a/pn$ for some $a\in\mathbb{N}$. Define:
$$
c'\br{v}=\begin{cases}
    \cl{c\br{c}}_k, & \text{if } c\br{v}>pk, \text{ in which case the vertex will be called \textit{heavy}},\\
    \cl{c\br{c}}_{\frac{1}{pn}}, & \text{otherwise, in which case the vertex will be called \textit{light}}.\\
\end{cases}
$$

\begin{lemma}\label{rounded_dt_lemma}
    $$
    \OPT\br{T,c'}\leq \br{1+\frac{2}{p}}\cdot \OPT\br{T,c}
    $$
    \begin{proof}
        Let $D^*$ be an optimal strategy for $\br{T,c}$. By definition, we have that for every vertex $v\in V\br{T}$, $c'\br{v}\leq \br{1+\frac{1}{p}}\cdot c\br{v}+\frac{1}{p}n$ and therefore:
        \begin{align*}
            \OPT\br{T, c'}&\leq \COST_{D^*}\br{T,c'}=\max_{v\in V\br{T}}\brc{\sum_{q\in Q_{D^*}\br{T,v}}c'\br{q}}
            \\&
            \leq \max_{v\in V\br{T}}\brc{\sum_{q\in Q_{D^*}\br{T,v}}\br{\br{1+\frac{1}{p}}\cdot c\br{v}+\frac{1}{pn}}}
            \\&
            \leq \frac{1}{p}+\br{1+\frac{1}{p}}\cdot \max_{v\in V\br{T}}\brc{\sum_{q\in Q_{D^*}\br{T,v}}c\br{v} }\leq \br{1+\frac{2}{p}}\OPT\br{T,c}
        \end{align*}

        where in the third inequality we used the fact that for every $v\in V\br{T}$, $\spr{Q_{D^*}\br{T,v}}\leq n$ and in the last inequality we used Observation \ref{basicBoundsOnCost}.
    \end{proof}
\end{lemma}

While calculating the decision tree, we will divide the time into boxes of duration $k$, which will be further subdivided into $a$ identical slots of length $\frac{1}{pn}$. Let $t_q$ denote the start of some query in a decision tree $D$. Note that the numbers $t_v$ provide a complete information about any decision tree, and are an equiavalent representation of any strategy. We will assume that for any heavy vertex $v\in V\br{T}$, $t_v$ is an integer multiple of $c$ and for any light vertex $v\in V\br{T}$, $t_v$ is an integer multiple of $\frac{1}{pn}$. \footnote{Note that by doing so, we allow decision trees to contain idle time intervals, in which no queries are scheduled. However, if this occurs, after obtaining such decision tree, we simply delete the idle times, which results in a valid decision tree} We have the following lemma:
\begin{lemma}\label{aligned_dts_lemma}
    There exists a decision tree $D$ for $\br{T,c'}$, such that $\COST_{D}\br{T, c'}\leq \br{1+\frac{3}{p}}\cdot\OPT\br{T, c'}$ and for every vertex $v\in V\br{T}$ we have:
    \begin{enumerate}
        \item if $c\br{v}> pk$, then $t_v/k\in\mathbb{N}$ (every heavy query is aligned to a multiple of $c$),
        \item if $c\br{v}\leq pk$, then $t_vpn\in\mathbb{N}$ (every light query is aligned to a multiple of $\frac{1}{pn}$).
    \end{enumerate}
    \begin{proof}
        Let $D^*$ by any optimal decision tree for $\br{T,c'}$. For any $v\in V\br{T}$, let $t_v^*$ be the start of query to $v$ in $D^*$ and let $t_v'=\br{1+\frac{2}{p}}t_v^*$, thus construction a new decision tree $D'$. Since in this new decision tree $D'$, the ordering of vertices is exactly the same as in $D^*$, for any two consecutive queries $v,u$ in $D'$ we have:
        $$
            t_u'-t_v'=\br{1+\frac{2}{p}}\cdot\br{t_u-t_v}\geq \br{1+\frac{2}{p}}\cdot c\br{v}
        $$

        We now construct $D$ as follows: If $v\in V\br{T}$ is heavy, we assign $t_v=\cl{t_v'}_k$ and $t_v=t_v'$ otherwise. For any two consecutive queries $v,u$ in $D$, such that $v$ is heavy we have:
        $$
        t_u-\cl{t_v'}_k>t_u-t_v-k\geq \br{1+\frac{2}{p}}\cdot c\br{v}-k>w\br{v}+k>c'\br{v}
        $$

        So we conclude that no two queries overlap. To obtain the second part of the claim, we round up the starting time of each query to a light vertex in $D$ to an integer multiple of $\frac{1}{pn}$. We have:
        \begin{align*}
            \COST_{D}\br{T,c'}&
            \leq \max_{v\in V\br{T}}\brc{\sum_{q\in Q_{D^*}\br{T,v}}\br{\br{1+\frac{2}{p}}\cdot c'\br{v}+\frac{1}{pn}}}
            \\&
            \leq \frac{1}{p}+\br{1+\frac{2}{p}}\cdot \max_{v\in V\br{T}}\brc{\sum_{q\in Q_{D^*}\br{T,v}}c'\br{v} }\leq \br{1+\frac{3}{p}}\OPT\br{T,c'}
        \end{align*}

        where in the third inequality we used the fact that for every $v\in V\br{T}$, $\spr{Q_{D}\br{T,v}}\leq n$ and in the last inequality we used Observation \ref{basicBoundsOnCost}.
    \end{proof}
\end{lemma}

We will call a decision tree fulfilling above conditions \textit{aligned}. In subsequent considerations, we will focus ourselves of finding such decision trees, whose properties will allow us to devise an efficient dynamic programming procedure finding an optimal, aligned decision tree. 

\subsubsection{Heavy module contraction, up and down responses}
Since, our decision tree is rooted, we can reasonably talk about up and down responses to a query. An \textit{up} response to a query to $v$ in $T$ occurs when the connected component $\in T-v$, which is the reply happens to contain $r\br{T}$. If this is not the case, then such response is called a \textit{down} response. As it will turns out, a repeating occurance of light queries with down responses will become problematic for our algorithm. To account for this issue we will use the following notions:

We will define a new measure of cost for aligned decision trees called the \textit{aligned cost}. Let $D$ be any aligned strategy for $\br{t,c'}$. For any  vertex $v\in V\br{T}$ and query $q\in Q_{D}\br{T,v}$ the contribution $\kappa_{T,c,k}\br{q,v}$ of $u$ is defined as:
$$
\kappa_{T,c}\br{q, v}= \begin{cases}
    \fl{t_v+c\br{q}}_k-t_v, & \text{if } c\br{v}\leq pk \text{ and the response to query $q$ in $T$, towards $v$ is down},\\
    c\br{q}, & \text{otherwise}.
\end{cases}
$$

Then, the \textit{aligned cost} of $D$ is defined as:

$$
\COST'_D\br{T,c',k}=\max_{v\in V\br{T}}\brc{\sum_{q\in Q_D\br{T,v}}\kappa_{T,c', k}\br{q,v}}.
$$

Let $\OPT'\br{T,c',k}$ denote the optimal aligned cost among all aligned decision trees for $\br{T,c',k}$.
Notice that in the above cost, we lose $k$ query time per light query with a down response. Since of course, the amount of such queries may be of order $O\br{n}$, the difference between $\COST'_D\br{T,c',k}$ and $\COST_D\br{T,c',k}$ may grow almost arbitrarily large. However, we will make sure that this does not happen to often, which will give us the desired bound on the cost of the solution. We have the following simple observation:
\begin{observation}\label{aligned_subtree_opt_observation}
    Let $T'$ be a subtree of $T$. Then, $\OPT'\br{T'}\leq\OPT'\br{T}$.
\end{observation}

\input{figures/heavy_module_contraction.tex}
We define a \textit{heavy module} as $H\subseteq V\br{T}$ such that: $T[H]$ is connected, every $v \in H$ is heavy, i. e., $c\br{v}\geq pk$ and $H$ is maximal - no vertex can be added to it without violating one of its properties. A \textit{contraction} of a heavy module $H$ is an operation which consists of deleting all of the vertices in $H$ from $T$ and connecting every vertex $u$ which was a child of some vertex in $H$ to the parent of $r\br{T\angl{H}}$ if it exists. For example see Figure \ref{exampleHeavymoduleContraction}.

\subsubsection{The main procedure}

We will use the following proposition about the existence of the \FBuildDT procedure:
\begin{proposition}\label{BuildDTPropodisition}
     Let $T$ be a tree, $c:V\br{T}\to \mathbb{R}_{>0}$ be an aligned cost function, $F_C$ be a forest of decision trees for $T$ with all heavy groups contracted, $p\in \mathbb{N}$ be a constant, $k\in \mathbb{R}_{>0}$ be the box size and $d\in \mathbb{N}$ be maximal depth. There exists a \FBuildDT procedure which:
     \begin{enumerate}
        \item Either determines that $kd\leq \OPT'\br{T, c',k}$ and returns an aligned decision tree $D$, such that:
        $$
            \COST_{D}\br{T,c',k}=\OPT'\br{T,c',k}+pk\cdot \COST_{D_C}\br{T,1}.
        $$
        \item Or determines that $kd > \OPT'\br{T, c',k}$.
        \item The procedure runs in $\br{pn}^d$ time.
     \end{enumerate}
\end{proposition}
The proof will be provided in the next section.
We will now prove the Proposition \ref{QPTAS}.

\input{pseudocodes/qptas.tex}

The Algorithm \ref{qptas_pseudocode} starts by picking $p=\cl{\frac{24}{\epsilon}}$ and assigning $k=0$ and $d=p^2\cdot\br{\fl{\log n}+1}$. At each iteration of the repeat loop, the algorithm picks $k$ to be the next 
integer multiple of $\frac{1}{pn}$, performs the rounding operation introduced above, creates a decision tree $D_C$ for tree $T$ with all heavy modules contracted and tries to create decision tree $D$, by applying Proposition \ref{BuildDTPropodisition}. Once the \FBuildDt procedure returns a non-empty solution, the \FQPTAS procedure terminates and returns the constructed decision tree $D$. Let $k'$ be the value of $k$ for which $D$ was found. Since we know that $k'\leq \frac{\OPT'\br{T,c',k'}}{d}=\frac{\OPT'\br{T,c'}}{p^2\cdot\br{\fl{\log n}+1}}$, we have that:
\begin{align*}
    \COST_{D}\br{T,c'}&\leq \OPT'\br{T,c'}+pk'\cdot \br{\fl{\log n}+1}\leq \OPT'\br{T,c'}+p\cdot \br{\fl{\log n}+1}\cdot \frac{\OPT'\br{T,c'}}{p^2\cdot\br{\fl{\log n}+1}} \\
    & \leq \br{1+\frac{1}{p}}\cdot\OPT'\br{T,c'}\leq \br{1+\frac{1}{p}}\cdot\br{1+\frac{2}{p}}\cdot\br{1+\frac{3}{p}}\cdot\OPT\br{T,c}
    \\&
    \leq \br{1+\frac{24}{p}}\cdot\OPT\br{T,c} = \br{1+\frac{24}{\cl{\frac{24}{\epsilon}}}}\cdot\OPT\br{T,c}\leq \br{1+\epsilon}\cdot \OPT\br{T,c}
\end{align*}
    
where the second inequality is by applying Corollary \ref{vertexRankingCorollary} and the fourth inequality is by Lemma \ref{rounded_dt_lemma} and Lemma \ref{aligned_dts_lemma}.

We can assume that $c=\text{poly}\br{n}$, since beyond that the problem can be solved to optimality in $O\br{2^nn}$ time. Therefore the running time of the procedure is bounded by:
$$
n^{O\br{d}}=n^{O\br{p^2\log n}}=n^{O\br{\log n/\epsilon^2}}.
$$
\subsubsection{Proof of Proposition \ref{BuildDTPropodisition}: medusa tree construction}

We will use the following proposition:

\begin{proposition}\label{DPTimelinesCostsProposition}
    Let $T$ be a tree, $c$ an aligned cost function, $p\in \mathbb{N}$, $k$ the box size, $n$ the size of the original input tree, $d$ depth and $\mathcal{A}:V\br{T}\to 2^{\mathbb{D}}$ be a dictionary, where $\mathbb{D}$ is a set of all decision trees. There exists an algorithm \FDPTimelinesCosts which calculates an optimal aligned decision tree $D$, such that for every $v\in V\br{T}$, each $D'\in\mathcal{A}[v]$ is hanged below $v$ in $D$, running in $pn^{O\br{d}}$ time.
\end{proposition}
The prove of the proposition is provided in the next section.

\input{pseudocodes/build_dt.tex}
\input{figures/medusa.tex}

The algorithm \ref{buildDTpseudocode} takes as arguments a tree $T$, a cost function and a forest of decision trees $F_C$ for $T$ with heavy groups contracted. It should be noted that, whenever $r\br{T}$ is heavy, then after contracting all heavy groups the resulting graph $T_C$ may not be connected, since there is no light parent vertex of a heavy group $H$ containing $r\br{T}$, such that the children vertices of $H$ can be connected to. Based on this, we derive two cases for our procedure:
\begin{enumerate}
    \item $r\br{T}$ is light. In such case we build the decision tree $D=\br{\brc{r\br{D_C}}, \emptyset}$. Then, for each $T'\in T-r\br{D_C}$ we build a decision tree $D'$ recursively and hang $D'$ below $r\br{D_C}$ in $D$.
    \item $r\br{T}$ is heavy. In this case we construct the so called \textit{medusa tree}. A medusa tree is a tree $M$ containing one heavy heavy group $H$ called \textit{head}, such that $r\br{M}\in H$. Each connected component of $M-H$ will be called a \textit{leg}. To construct the medusa, we build two sets of vertices, the head $H$ and a set of vertices belonging to the legs of $M$, $L$. We pick $H$ to be the heavy group in $T$, such that $r\br{T}\in H$. Then we pick $L$ to be set of light vertices in $V\br{T}$. However, we exclude all vertices, $u \in V\br{F_C}$, such that there exists a ancestor $v$ of $u$ in $F_C$, which is also its ancestor in $T$. Then we build $M$ by connecting the vertices $u,v \in V_M=L\cup H$, such that $\mathcal{P}_{u,v}\cap V_M=\emptyset$. We construct a dictionary $\mathcal{A}$, which entries consist of $V_M$. For each $T'\in T-V_M$, we then construct a decision tree $D'$ recursively and add it to $\mathcal{A}[v]$ for $v$ such that $v$ is the parent of $r\br{T'}$. We then build a decision tree $D$, by applying Proposition \ref{DPTimelinesCostsProposition} for $M$.
\end{enumerate}

\begin{lemma}
Let $D$ be the decision tree returned by the \FBuildDT procedure. Then, $\COST_D\br{T,c}\leq \OPT'\br{T,c, k} + pk\cdot \COST_{F_C}\br{T_C, 1}$, where $T_C$ is the $T$ with heavy groups contracted.
\begin{proof}
    Assume by induction that the claim holds for all subtrees of $T$, for which the procedure is called recursively. We have two cases:
    \begin{enumerate}
        \item $r\br{T}$ is light. Then, $F_C$ is connected and we have:
        \begin{align*}
        \COST_{D}\br{T,c}&=c\br{r\br{F_C}}+\max_{T'\in T-r\br{F_C}}\brc{\COST_{D'}\br{T'}} 
        \\&\leq 
        pk+\max_{T'\in T-r\br{F_C}}\brc{\OPT'\br{T',c, k} + pk\cdot \COST_{F'_C}\br{T'_C,1}} 
        \\&\leq 
        \OPT'\br{T,c, k} + c\br{r\br{F_C}}+\max_{T'\in T-r\br{F_C}}\brc{pk\cdot \COST_{F'_C}\br{T'_C,1}} 
        \\&= 
        \OPT'\br{T,c, k} + pk\cdot \COST_{F_C}\br{T_C,1}
        \end{align*}

        where the first inequality is by the induction hypothesis, the second inequality is by the fact that every $T'\in T-r\br{F_C}$ is a subtree of $T$ (Observation \ref{aligned_subtree_opt_observation}) and the second equality is be the definition of the cost of a decision tree.
        \item $r\br{T}$ is heavy. Let $D^*$ be the optimal aligned decision tree for $T$. We will build a decision tree $D''$ using $D^*$ with the following property: for every $v\in V\br{T}-V_M$, the query to the closest ancestor $u$ (which is a light query) of $v$ in $T$, happens before $v$. We will call a decision tree with such property \textit{hierarchical}. To do so, let $u\in L$. Assume Let $F'_u$ be a forest of trees which are members of $T-V_M$, and $u$ is their parent. Assume that there exists a query in $F'_u$, which is an ancestor of $u$ in $D^*$. Let $v\in V\br{F'_u}$, such that $v$ is an ancestor of every query among $V\br{F'_u}$ in $D^*$. Note that, there always is such query, since any query which could divide queries to vertices of $V\br{F'_u}$ into separate branches in $D^*$, either belongs to $V\br{F'_u}$ or is $u$, and we assumed that there exists a query in $D^*$ which is an ancestor of query to $u$. 
        
        Firstly, we replace the query to $u$ with a query to $v$. Note that such operation, does not increase the search time of vertices which belong to the up response to the previous query at $v$. We then hang $v$ (with all its previous right children in $D^*$) as a right child of the query to $u$, and we obtain a valid decision tree. Since after all such operations, for every $x\in V\br{T}$, $Q_{D''}\br{T,x}\subseteq Q_{D^*}\br{T,x}\cup Q_{F_C}\br{T,x}$. By definition of the decision tree and optimality of $D^*$, we therefore have that $\COST_{D''}\br{T,c}\leq\OPT'\br{T,c, k} + pk\cdot \COST_{F_C}\br{T_C}$. 
        
        Let $D^*$ be an optimal hierarchical decision tree. Let $T'$ be any subtree of $T$, such that $T'\in F'_u$ for some $u\in L$. Let $v$ be the first query in $D^*$ to a vertex of $V\br{T'}$. Since each such query happens after a query to $u$, we have that $V\br{T'}=V\br{D_{v}^*}$. We will assume, that $\COST_{D_{v}^*}\br{T'}= \OPT\br{T'}$. We call a decision tree with this property \text{hierarchically optimal}. If otherwise, one can always replace $D_{v}^*$ with an optimal decision tree for $T'$, without increasing the cost.

        By construction, the decision tree $D$, returned by the procedure is hierarchical and by induction hypothesis and Proposition \ref{DPTimelinesCostsProposition} is also hierarchically optimal, so $\COST_{D}\br{T,c}\leq \COST_{D''}\br{T,c}$ and the claim follows.

    \end{enumerate}
\end{proof}
\end{lemma}


\subsubsection{Dynamic programming procedure for a fixed box size}

\input{figures/box_dt.tex}

To devise our dynamic programming procedure, we will need the following generalization of an hierarchical decision trees. A \textit{boxed decision tree} $D=\br{V\br{D}, E\br{D}, u, l}$ for the tree $T$ is a tuple, in which $V\br{D}$ are the nodes of the decision trees, which we will call \textit{boxes}, $E\br{D}$ are edges of the decision tree, $u:V\br{T}\times V\br{D}\to \brc{0, 1/pn,2/pn,\dots,k}$ is the \textit{usage} function and $l:V\br{D}\to\brc{0, 1/pn,2/pn,\dots,k}$ is the \textit{load} function. Based on $u$, for every $b\in V\br{D}$ we will also define the \textit{query assignment} as following: $Q\br{b}=\brc{v\in V\br{T}|u\br{v,b}>0}$, these are the vertices of $T$, such that queries to them overlap with the box $b$.

The boxed decision tree is defined analogously as ordinary decision tree, however, to each query in $b\in V\br{D}$ instead of one vertex of $V\br{T}$, we assign an arbitrary subset of $V\br{T}$, via the query assignment function $Q$. Let $b\in V\br{D}$, and let $T'$ be a candidate subtree of $T$ right before any vertex in $Q\br{b}$ was queried. A box $p$ is a left child of $b$, if either $b$ corresponds to a subtree $T''\in T-Q\br{b}$ such that $r\br{T'}\in V\br{T''}$ or $Q\br{b}\cup Q\br{p}\neq \emptyset$. If otherwise, then $p$ is a right child of $b$.

We demand that for every $v\in V\br{T}$, all boxes $b\in V\br{D}$, such that $v\in Q\br{b}$ form a connected path in $D$, in which every child is a left child, for any intererior box $b$ of this path, $l\br{b}=0$ and $u\br{v,b}=k$. We will also require that: for every $q\in V\br{D}$, $l\br{b}+\sum_{v\in V\br{T}}u\br{v,b}\leq k$ and for every $v\in V\br{T}$ either $\sum_{b\in V\br{D}}\br{v,b}=0$, in which case such query is called \textit{unassigned} or $\sum_{b\in V\br{D}}\br{v,b}=c\br{v}$ and the query is called \textit{assigned}. Since we want the boxed decision tree to also be aligned, we will demand that if for any vertex $v\in V\br{T}$, $c\br{v}>pk$, then for every $b\in V\br{D}$, either $u\br{v,b}=0$ or $u\br{v,b}=k$. 

We now define how to search in $T$ using a boxed decision tree $D$. Firstly, the query process stops for time $l\br{u}$. If $Q\br{r\br{D}}\cup V\br{T} = \emptyset$, then we recurse on the appropriate child of $r\br{T}$ (which corresponds to our current candidate subtree). Otherwise, we pick the least costly vertex $v$ in $Q\br{r\br{D}}$, we remove $v$ from $Q\br{q}$ for any $q\in V\br{D}$ and we recurse on the last box which contained a query to $v$ (note that this can also be $r\br{v}$). This is done in order to ensure that the start of the query $t_v$ of each vertex $v$ happens in the box containing it. The aligned cost of seaching using a boxed decision tree is defined analogously as the aligned cost of searching using ordinary decision tree.

\input{pseudocodes/dp_timelines_costs.tex}

Note that any boxed decision tree, can also be transformed to an equivalent aligned decision tree with the same aligned cost of searching. We want our boxed decision trees to also be hierarchical. Since we will build boxed decision trees only for medusa trees constructed in Algorithm \ref{buildDTpseudocode}, to fulfill the hierarchicality, it will suffice to satisfy the following condition. For every box $q\in V\br{D}$, let $\mathcal{A}[q]=\bigcup_{v\in Q\br{q}\mathcal{A}[v]}$. We require that each decision tree $D'\in \mathcal{A}\br{q}$ is hanged as a right child of $q$ in $D$.

We define a \textit{boxline} $B\angl{\br{b_1, \tau_1},\br{b_2, \tau_2},\dots, \br{b_d, \tau_d}}$ to be a sequence of pairs, each consisting of box and additional boolean flag, such that for every box $b$ in $B$, $Q\br{b}=\emptyset$. We will build our decision trees around boxlines. Define the \textit{left box-path} $B_D=\angl{{q_1, f_1},\br{q_2, f_2},\dots, \br{q_h, f_h}}$ of $D$ as a sequence of pairs. Each such pair consisits of the overall loads of consecutive boxes obtained by traversing $D$ starting from root $r\br{D}$, and stepping to the left child until there is none (for each such box $b$ with index $j$, $q_j=l\br{b}+\sum_{v\in Q\br{b}}q\br{v, b}$), and boolean values denoting whether there exists a query trascending the current box unto the next one ($f_h$ is always false, however we include it for convenience). We will say that a decision tree $D$ with a left box-path $B_D$ is \textit{box-compatible} with a boxline $B$, such that $h\leq d$, if for every integer $1\leq j \leq h$, $l\br{q_j}\geq l\br{b_j}$ and if $\tau_j$ implies $f_j$. To build a decision $D$ tree using $B$, we simply create a boxed decision tree $D$ consisiting of path of vertices $\angl{q_1,\dots, q_h}$, such that $l\br{q_j}=l\br{b_j}$ and $Q\br{q_j}\emptyset$.

We will also use the following operations: 
\begin{enumerate}
    \item Putting a a query to $v\in V\br{T}$ at slot with index $d$ of a box $b$ of the boxline $B$. Set $\sigma\br{v}=c\br{v}$. To put a query at a slot $s$ of $b$, we set the usage $u\br{v, q}=\min\brc{k-s/pn, \sigma\br{v}}$ and we decrease $\sigma\br{v}$ by $u\br{v, q}$. If $\sigma\br{v}>0$, we recurse on the left child box of $b$ in $B$. If such operation violates the definition of $D$, we mark $D$ as \textit{conflicted}. It should be noted that we will also require that placing a query to $v$ cannot transcendent any box $b_j$, such that $\tau_j$. If this is violated, then the decision tree is also marked as conflicted. 
    \item Rotation of a decision tree $D$ around a vertex $v\in V\br{T}$: Let $q_h$ be the box containing the end of the query to $v$. Sort vertices whose queries start in $Q\br{q_h}$ according to $c$, create box $q$, move queries from $Q\br{q_h}$ to $Q\br{q}$, so that all queries after $v$ are in $Q\br{q}$, hang $q_h'$ as a right child of $q_h$ and rehang left child of $q_h$ as a left child of $q$.
    \item Bipartitioning of boxline $B$. A valid bipartition of $B$ consists of two boxlines $B_1$ and $B_2$ obeying the following rules: $\spr{B}=\spr{B_1}=\spr{B_2}$, $l\br{b_{1,j}}+l\br{b_{2,j}} - k = l\br{b_j}$ and $\br{\tau_{1,j}\land \tau_{2,j} \iff \tau_{j}}\land \br{\tau_{1,j}\lor \tau_{2,j}}$.
\end{enumerate}

We now introduce the subproblems which our dynamic programming solves. A problem $\OPT'\br{T_{v,i},B}$ consists of finding an optimal boxed decision tree for the tree $T_{v,i}$, which is box-compatible with $B$. If no $B$ is given, we assume that $B=\angl{\br{b_1,\tau_1},\dots, {b_d,\tau_d}}$, where for every $1\leq j\leq d$, $b_j=0$ and $\tau_j$ is false.
 The algorithm computes the solutions in a bottom-up, left-to-right manner. If at any point there is no way to create an extended decision tree with given parameters we simply declare such instance \textit{unfeasible}. We will now show how to compute $\OPT\br{T_{v,i}, P}$ efficiently. The Algorithm \ref{dp_timelines_costs} consists of 3 cases:
 
\input{figures/dp_timelines_costs.tex}

 %TODO: rewrite this:
 
    \begin{enumerate}
        \item $T_{v,0}$, in this case we greedily pick the smallest index $1 \leq k \leq \spr{P}$, such that $p_k$ is unassigned. If there is no such index, we declare the subproblem unfeasible. In other case, the solution obtained by taking timeline $P$ and setting $p_k=v$. The cost of such solution is $w(v)\cdot k$.
        \item $T_{v,1}$, let $u$ be the unique child of $v$ in $T_{v,1}$. We assume that we have already solved all the subproblems of $T_u$.
        We iterate through all possible choices of $1\leq k \leq h$, such that $p_k$ is unassigned. If there are no such choices, we declare the subproblem unfeasible. If otherwise, for each such $k$, we create an auxiliary timeline $P_k'=
        \angl{p_1',\dots,p_h'}$, such that $p_l'=p_l$ for $l < k$, $p_k'$ is blocked and $p_l'$ is unassigned for $l>k$. We consider an optimal extended decision tree $D'_k$ for an instance $\mathcal{P}\br{T_{u}, P_k'}$. In order to create a new decision tree $D_k$, for each choice of $k$, we proceed as follows: Let $q'_k$ be the $k$-th vertex of the left path of $D'_k$. We set $q'_k=v$ Then, we take the left child of $q'_k$ in $D'$ and we rehang it as the right child of $q'_k$.
        % Additionally we fill the left path of $D'$ with blocked and unassigned vertices in order to make it again compatible with $P$.
        The cost of each such extedned decision tree is $\OPT\br{T_{u}, P_k'}+w(v)\cdot k$. We then return an optimal extended decision tree $D$, which minimizes the cost.
        \item $T_{v,i}$ for $i>1$, we assume that we have already solved all the subproblems of $T_{v,i-1}$ and $T_{c_i}$. Let $I$ be a set of indices of unassigned nodes of $P$, i.e. $I=\brc{l | p_l \text{ is unassigned}}$. Consider any bipartition $\br{I_1, I_2}$ of $I$. We create a timeline $P_1=\angl{p_{1,1},\dots,p_{1,h}}$ from timeline $P$, by blocking all of the nodes in $P$ whose indices do not belong to $I_1$. We now consider an extended decision tree $D_1$ for $\mathcal{P}\br{T_{v,i-1}, P_1}$, with a left path $\angl{q_{1,1},\dots,q_{1,d_1}}$. Let $k$ be the index of query to $v$, such that $q_{1,k}=v$. We construct $P_2=\angl{p_{2,1},\dots, p_{2,h}}$ as follows: for any $1\leq l\leq h$, we set $p_{2,l}$ to be unassigned if $l\in I_k^2$ or $l < k$ and we set $p_{2,l}$ to be blocked otherwise. Let $D_2$ be an optimal extended decision tree for $\mathcal{P}\br{T_{c_i}, P_2}$ and let $\angl{q_{2,1},\dots,q_{2,d_2}}$ be its left path. We proceed as follows. Firstly, we rehang the left child of $q_{2,k}$ in $D_2$ as its unique right child (by construction $q_{2,k}$ is blocked in $D_2$). Then, we build $D$ by aligning $D_1$ and $D_2$ by their left paths: For $1\leq l \leq k$, if $p_l$ is blocked then $q_l$ is blocked. Else, if $p_{1,l}$ is unassigned, then $q_l=q_{1,l}$. Else, if  $p_{2,l}$ is unassigned, then $q_l=q_{2,l}$. For $k<l\leqh$ we set $q_l=q_{1,l}$. Since the unassigned nodes above the $k$-th node of left paths of $D_1$ and $D_2$ have no conflicts and $D_2$ has no vertices in its left path beyond $q_{2,k}$, by construction we obtain a valid extended decision tree $D$. The cost of such solution is $\OPT\br{T_{v,i-1}, P_1}+\OPT\br{T_{c_i}, P_2}$. We then return an optimal extended decision tree $D$, which minimizes the cost. 
        % For a visual example, see \ref{dp_timelines_figure}.
    \end{enumerate}

 








