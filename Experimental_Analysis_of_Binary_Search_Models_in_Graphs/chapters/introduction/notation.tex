\section{The three field notation for the search problem}
The multiplicity of variants for the problem motivates the following notation. Throughout this work we will use the following three field notation resembling the notation commonly used in task scheduling problems. Our notation will consists of the three fields: $\alpha, \beta$ and $\gamma$. The $\alpha$ field is the search space environment field resembling the machine environment. The $\beta$ field is the query characteristics which resembles the job characteristics. The $\gamma$ field is the objective function which we are trying to optimize. In order not to confuse the two notations we will separate the fields for the graph searching notation with double lines $||$ instead of $|$. The following table showcases example variants which may be considered:

\begin{table}[ht]
\centering
\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\text{$\alpha$ - search space } & \text{$\beta$ - query characteristics } & \text{$\gamma$ - objective value} \\
\hline
$P$ - paths
\newline
$T$ - trees
\newline
$POSET$ - POSETs
\newline 
$G$ - graphs
\newline
$HT$ - hypertrees
\newline
$HG$ - hypergraphs
& 
$E$ - edge queries
\newline
$V$ - vertex queries
\newline
$Q$ - any queries
\newline
$c$ - cost function on queries
\newline
$w$ - weight function on vertices
\newline
$d$ - due dates/deadlines
\newline
$r$ - release times
\newline
$prec$ - precedences
& 
$C_{max}$ - maximum search time
\newline
$\sum C_i$ - average search time
\newline
$\sum U_i$ - throughtput
\newline
$F_{max}$ - maximum flow time
\newline
$\sum F_i$ - average flow time
\newline
$L_{max}$ - maximum lateness
\newline
$\sum L_i$ - average lateness
\newline
$T_{max}$ - maximum tardiness
\newline
$\sum T_i$ - average tardiness
\\
\hline
\end{tabularx}
\caption{Sample values for the three field notation for the search problem.}
\end{table}

The striking resemblance between these two notations suggests that we can view the search problem as a specific variant of task scheduling, in which the search strategy is the schedule and the queries are the jobs. At the start of the schedule there is only one machine processing the queries. After completing each such job, the machine that was processing it is replaced by a new set of machines, one for each possible response to the query. Additionally, from this moment on each such machine only processes the queries to vertices belonging to response associated with it.

In contrast to the classical scheduling the search problem is not nearly as explored and most of the variants which can be constructed using the table above are not even mentioned in the literature. It also seems, that the search problem is usually harder than the corresponding scheduling variants. For example, the best algorithm known for the NP-hard variant $T||V, c||C_{max}$ achieves an $O\br{\sqrt{\log n}}$-approximation \cite{dereniowski2017ApproxSsForGeneralBSinWTs}. A somewhat similar scheduling problem $P||C_{max}$ has a simple $\frac{4}{3}$-approximation algorithm based on sorting the jobs according to their costs \cite{BoundsonMultiprocessingTimingAnomalies}, admits a PTAS for an unbounded number of machines \cite{Binpackingwithrestrictedpiecesizes} and if the number of machines is bounded an FPTAS can be obtained \cite{AlgorithmsforSchedulingIndependentTasks}.
