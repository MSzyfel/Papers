\section{Motivations and applications}

Fast retrieval of information in graph structures is a fundamental problem in computer science and related fields. Graphs are widely used to model complex relationships and structures in various domains, including social networks, transportation systems, biological networks, and communication networks. Efficiently searching for specific information within these graphs is crucial for applications such as data mining, network analysis, and decision-making processes.
When the underlying search space provides non-local information about the target, 
the search process can be accelerated, since each query rules out a large set of 
possible target locations. The goal of designing search strategies is to find ways of exploiting this property as effectively as possible. 

Searching arises in various practical problems, but it can also be reformulated, to fit a wide range of real-life applications. Searching in graphs can be used to model a variety of problems, that may initially appear unrelated. These include: 
\begin{enumerate}
    \item Automated bug detection in computer code \cite{OptimalSinT,dereniowski2022CFApproxAlgForBSInTsWithMonoQTimes,dereniowski2024SInTsMonoQTs,szyfelbein2025searchingtreeskupmodularweight}. This use case involves locating the source of an error in a program's semantic structure by performing unit tests, each verifying whether the tested code segment contains the error. The resulting graph is a tree in which each child node represents a subsection of a given code segment. The objective is to minimize the total time required to identify the erroneous code segment by strategically selecting which segments to test. 
    \item Version control systems and regression bug identification \cite{10.1007/978-3-031-20624-5_10}. In software development projects using Version Control Systems (VCS) like git or mercurial, the project's evolution forms a Directed Acyclic Graph (DAG) where vertices represent commits (project versions) and edges model changes between versions. When a regression bug is discovered, developers must identify the specific commit that introduced the error by performing queries on historical commits. Each query involves testing a commit to determine whether it contains the bug or is clean, which can be extremely time-consuming (potentially requiring compilation, extensive testing, or manual verification). When the input DAG is a tree, this problem reduces to the tree search problem.
        \item Hierarchical clustering of data \cite{Acostfunctionforsimilaritybasedhierarchicalclustering,HCObjFsandAlgs,Approximatehierarchicalclusteringviasparsestcutandspreadingmetrics}. In this application, the objective is to construct a hierarchical clustering of data points by querying pairwise similarities. The data points are represented as nodes in a graph, and edges represent similarity measures. By querying specific pairs of nodes, one can partition the data points into separate clusters, thereby building a hierarchical clustering of data.
        \item Bayesian active learning problem \cite{BayesianLearnerOptimalNoisyBinarySearch,Cicalese2016DecTreesSimEval,ATightAnalysisofGreedy,Tradingoff,QuerySelection,CarmoSInRandPOSets,OnanOptimalSplitTreeProblem,Diagnosisdetermination,Karbasi2013Constrained}. In this scenario, the goal is to determine a correct hypothesis among the possibly very large set of possibilities. To do so the learner can execute tests which sample the features of the hypothesis revealing a partial information about the target. Each test is a partition of the input space. By strategically selecting features to test, one can build a decision tree that minimizes the classification time. If the partitions incurred by the tests form a tree like hierarchy this problem reduces to the graph search problem. This problem has applications in various domains, including medical diagnosis, fault detection in systems, and criminal investigations.
        \item VLSI routing and layer assignment \cite{OnAGPartWAppVLSI}. In VLSI circuit design, one is required to find a partition of \textit{nets} connecting \textit{terminals} into separate conductor layers in order to ensure that no such nets cross each other. In the \textit{generalized river routing} variant of this problem, placing a net on each layer may incur different costs. Therefore, it is beneficial to assign as many nets to the cheapest layers as possible. Decision trees model the sequential layer assignment choices, where each level of the decision tree corresponds to the set of nets assigned to a layer. The objective is to minimize the total cost of layer assignments while ensuring that no nets cross each other.
        \item Parallel assembly of multi-part products from their components \cite{ParAofModPs,Dereniowski2009ERankOfWTs}. The objective is to assemble complex products by performing assembly operations in parallel. The components of the product are represented as nodes in a graph, and hyperedges represent groups of such components which at some point need to be joined together. We assume that no component can undergo two join operations simultaneously. Therefore, the set of join operations performed at any given time is a matching. It can be showed that by reversing the ordering of queries given by the shallowest decision tree of the hyperedge search problem on the graph representing the query plan, one can obtain an optimal schedule for the join operations. A special case of this problem includes scheduling of parallel database join operations \cite{DereniowskiEfPQProcByGRank,OnMinERSTs,MinERSTrofTGs}. Here, the objective is to optimize the sequence of join operations required to process a database query. Each table is represented as a node, and edges represent join operations.
        \item Parallel Cholesky factorization of sparse matrices \cite{Dereniowski2003CholeskyFactofMx}. In sparse linear algebra, the Cholesky factorization of a symmetric positive-definite matrix can be parallelized by exploiting its sparsity structure. The matrix is represented as a graph, where nodes correspond to matrix rows/columns and edges represent non-zero entries. The \textit{elimination tree} captures column dependencies: if column $i$ is the parent of column $j$ in this tree, then $i$ must be computed before $j$. Vertices belonging to the same layer of the decision tree can be processed in parallel. The objective is to construct a decision tree with minimum height, thereby minimizing the number of parallel steps required for factorization.
        \item Investigative genetic genealogy and privacy-preserving search \cite{PrivateGeneticGenealogySearch}. In forensic investigations and genealogical research, decision trees can model the sequential process of identifying unknown individuals through genetic database queries. The genealogical network represents family relationships, where each node corresponds to an individual and edges represent genetic relatedness. Each query involves collecting a genetic sample and comparing it to the target genome to determine genetic distance. The decision tree guides the strategic selection of individuals for genetic testing, balancing two competing objectives: minimizing the number of expensive genetic samples collected (search cost) while limiting privacy exposure of individuals whose genetic information becomes compromised.
        \item Fast implementation of distance and shortest path queries \cite{Angelidakis2018ShortestPQ}. In this application, the goal is to efficiently answer distance and shortest path queries in large graphs. By constructing the so called \textit{hub labeling} of a graph, one can preprocess the graph to enable fast query responses. The hub labeling is an assignment of labels to each vertex, where each label contains a subset of vertices (hubs) such that for any pair of vertices, their labels contain a common hub on the shortest path between them. When the input graph is a tree, the problem of constructing an optimal hub labeling is equivalent to the tree search problem, since it can be proven that any optimal hub labeling can be transformed to a hierarchical form, in which the labeling of each vertex $v$ corresponds to the sequence of queries made when searching for $v$ using the corresponding decision tree.
\end{enumerate}

% Additionally, the worst case graph search time is a graph parameter called \textit{treedepth}