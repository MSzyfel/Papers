\chapter{Notions and Definitions}

\section{Graph theory}
A \textit{\gls{graph}} is a pair $G=\br{V\br{G}, E\br{G}}$ where $V\br{G}$ is the set of \textit{vertices} and $E\br{E}$ is the set of \textit{edges} which are unordered pairs of vertices. We denote $n\br{G}=\spr{V\br{G}}$ and $m\br{G}=\spr{E\br{G}}$. For $u,v \in V\br{G}$ by $uv$ we denote the edge which connects them. A \textit{subgraph} of a graph $G$ is another graph $G'$ formed from a subset of the vertices and edges of $G$. For any $V'\subseteq V\br{G}$ by $G[V']$ we denote the \textit{subgraph induced} by $V'$ in $G$ (i. e. for every $u,v\in V'$ if $uv\in E\br{G}$, then also $uv\in E\br{G'}$).  Additionally, by $G-V'$ we denote the set of connected components occurring after deleting all vertices in $V'$ from $G$. The set of \textit{neighbors} of $v\in V\br{G}$ will be denoted as $N_G\br{v} = \brc{u\in V\br{G}|uv\in E\br{G}}$ and the set of neighbors of subgraph $G'$ of $G$ as $N_G\br{G'} = \bigcup_{v\in V\br{G'}}N_G\br{v}-V\br{G'}$. By $\deg_{G}\br{v}=\spr{N_G\br{v}}$ we will denote the \textit{degree} of $v$ in $G$. By $\Delta\br{G} = \max_{v\in V\br{G}}\brc{\spr{\deg\br{v}}}$ we denote the degree of $G$.

A \textit{cycle} is a non-empty sequence of vertices in which for every two consecutive vertices $u,v$: $uv \in E\br{G}$ and only the first and last vertices are equal. A \textit{tree} $T$ is a connected graph that contains no cycle. A \textit{forest} is a (not necessarily connected) graph that contains no cycle. A \textit{path} $P$ is a tree such that $\Delta\br{P} = 2$. Let $v\in V\br{T}$. The \textit{outdegree} of $v$ in $T$ will be denoted as $\deg_T^+\br{v}=\spr{\mathcal{C}_T\br{v}}$.
By $P_{T}\br{u, v}=T\angl{\brc{u,v}}-\brc{u,v}$ we denote a path of vertices between $u$ and $v$ in $T$ (excluding $u$ and $v$). Analogously, for $V_1,V_2\in V\br{T}$ we define $P_{T}\br{V_1, V_2}=T\angl{V_1\cup V_2}-\br{V_1\cup V_2}$.
For any we denote the minimal connected subtree of $T$ containing all vertices from $V'$ by $T\angl{V'}$.

A partial ordering $\preceq$ is a two-argument relationship which is: reflective ($a\preceq a$), antisymmetric (if $a\preceq b$ and $b \preceq a$ then $a=b$) and transitive (if $a\preceq b$ and $b \preceq c$ then $a\preceq c$).
A poset is a pair $\mathcal{P}=\br{X, \preceq}$ where $X$ is the set of elements and $\preceq$ is a partial ordering of elements of in $X$. When clear from the context the set $X$ itself is also sometimes called a poset. 
\section{Optimization algorithms}
A \textit{minimization problem} is one in which given an input $I$, the set of valid solutions $S$ and a cost function $c:S \to \mathbb{R}^+$ we are required to find a solution $s^*\in S$ such that $c\br{s^*}=\min_{s\in S}\brc{c\br{s}}$. Analogously, a \textit{maximization problem} is one in which we are required to find a solution $s^*\in S$ such that $c\br{s^*}=\max_{s\in S}\brc{c\br{s}}$. For both types of problems we define $\OPT\br{I} = c\br{s^*}$. Given an instance $\br{I, S, c}$ of a minimization problem such that $\spr{I} = n$, an $\alpha\br{n}$-approximation algorithm is an algorithm which always outputs a solution $s$ such that:
$$
\frac{c\br{s}}{\OPT\br{I}} \leq \alpha\br{n}
$$
Analogously, for a maximization problem such an $\alpha\br{n}$-approximation algorithm is an algorithm which always outputs a solution $s$ such that:
$$
\frac{c\br{s}}{\OPT\br{I}} \geq \alpha\br{n}
$$
If $\alpha\br{n}=O\br{1}$ we say that the algorithm is a constant factor approximation algorithm for $I$. If $\alpha\br{n}=1$ we say that the algorithm is an exact algorithm for $I$. For a minimization problem if for every $0<\epsilon\leq1$ the algorithm provides a $\br{1+\epsilon}$-approximation (or a $\br{1-\epsilon}$-approximation in case of a maximization problem) and:
\begin{itemize}
    \item Runs in time $\text{poly}\br{n/\epsilon}$, then it is called a Fully-Polynomial Time Approximation Scheme (FPTAS).
    \item Runs in time $f\br{\epsilon}\cdot\text{poly}\br{n}$ for some computable function $f$, then it is called a Efficient-Polynomial Time Approximation Scheme (EPTAS).
    \item Runs in time $n^{O\br{1/\epsilon}}$, then it is called a Polynomial Time Approximation Scheme (PTAS).
    \item Runs in time $n^{\text{poly}\br{\log n/\epsilon}}$, then it is called a Quasi-Polynomial Time Approximation Scheme (QPTAS).
\end{itemize}

\section{The Search Problem}

Below we list the definitions regarding the search problem. We start with definitions of all viable search spaces and query models connected with them. Since the problem has a modular form and one can almost freely swap criteria and constraints, the number of separate variants is very large. Due to this we define all of the possible search spaces, query models and criteria separately and then we formulate the \textit{General Search Problem} based on the chosen variant.

\subsection{Search spaces with according query models}

The \textit{Tree Search Instance} consists of a pair $T=\br{V\br{T},E\br{T}}$. Among $V\br{T}$ there is a unique hidden target element $x$ which is required
to be located. During the \textit{Search Process} the searcher is allowed to iteratively perform a \textit{query} which asks about chosen vertex (or alternatively an edge $e$). If the answer is affirmative, then $v$ is the target, otherwise a connected component $H\in T-v$ is returned such that $x\in V\br
{H}$ (for the edge version always $H\in T-e$ is returned). Based on this information the searcher narrows the subtree of $T$ which might contain $x$ until there is only one possible option left.

The \textit{Graph Search Instance} consists of a pair $G=\br{V\br{G},E\br{G}}$. Among $V\br{G}$ there is a unique hidden target element $x$ which is required
to be located. During the \textit{Search Process} the searcher is allowed to iteratively perform a \textit{query} which asks about chosen vertex (or alternatively an edge $e$). If the answer is affirmative, then $v$ is the target, otherwise a connected component $H\in G-v$ is returned such that $x\in V\br
{H}$ (for the edge version always $H\in G-e$ is returned). Based on this information the searcher narrows the subgraph of $G$ which might contain $x$ until there is only one possible option left. 

\begin{remark}
    In the vertex query model we require that every vertex must be queried even when such vertex is the last among the candidate set. Note that it is sometimes assumed that in such case, this vertex does not need to be queried which may reduce the cost of the solution. Note that all of the algorithms showed in this work can be altered to take this assumption into account. For the sake of the brevity we do not include them but we encourage the reader to obtain them as an exercise.
\end{remark} 

The \textit{Poset Search Instance} consists of a pair $\mathcal{P}=\br{X, \preceq}$. Among $X$ there is a unique hidden target element $x$ which is required
to be located. During the \textit{Search Process} the searcher is allowed to iteratively perform a \textit{query} which asks about chosen element $v\in X$ and as the answers receives information whether $x\preceq v$. Based on this information the searcher narrows the subset of $X$ which might contain $x$ until there is only one possible option left.

The \textit{Binary Identification Problem Instance} consists of a pair $\mathcal{P}=\br{\mathcal{H}, \mathcal{Q}}$. In the \textit{Binary Identification Problem} we are given a pair $\br{\mathcal{H}, \mathcal{Q}}$ where $\mathcal{H}$ is a set of hypotheses and $\mathcal{Q}$ is a set of queries. Each query $q = \brc{R_1, R_2,...R_k}$ is a partition of $\mathcal{H}$ (we require that $\bigcup_{R\in q}R=\mathcal{H}$ and for any $R_1,R_2\in q$: $R_1\cap R_2=\emptyset$). Among $\mathcal{H}$ there is a unique hidden target hypothesis $x$ which is required
to be identified. During the \textit{Search Process} the searcher is allowed to iteratively perform a chosen query $q$. As the response the searcher obtains information which $R\in q$ contains the hidden target. Based on this information the searcher narrows the subset of $\mathcal{H}$ which might contain $x$ until there is only one possible option left.
\subsection{Additional input parameters}
As a part of the input we will also allow the cost function. Let $\mathcal{Q}$ be the space of possible queries. The cost of query $q\in\mathcal{Q}$ is then denoted
as $c:\mathcal{Q}\to \mathbb{R}^+$. We will also allow the weight function. Let $X$ be the space of the possible targets. The weight of query $x\in X$ is then denoted
as $w:X\to \mathbb{R}^+$. 
\subsection{Decision trees, optimization criteria and the Generalized Search Problem}
Let $I=\br{X\br{I}, \mathcal{Q}\br{I}}$ be an arbitrary search space and $c,w$ be the cost and weight functions. A decision tree is pair $D=(V\br{D}, E\br{D}, m)$ where $V\br{D}=X\br{I}$ are vertices and $E\br{D}$ are edges of $D$. 

It is required that each child of $q\in V\br{
D}$ corresponds to a distinct response to the query at $q$, with respect to the subset of candidate solutions that remain after performing all queries along the path $r\br{D}\circ P\br{r\br{D}, q}$. 

Let $Q_D\br{X\br{I},x}$ denote the sequence of queries made to locate a target $x \in X$ using $D$. We define the cost of searching for $x$ using $D$ in $\br{I,c}$ as:
$$
\COST_{max,D}\br{I, c, x} = \sum_{q\in Q_{D}\br{X\br{I},x}}c\br{q}
$$

We define the worst case cost of a decision tree $D$ in $I$ with weight function $w$ as:
$$
\COST_{avg, D}\br{I, w} = \max_{x\in X\br{I}} \brc{\COST_D\br{I, x}}
$$

By a slight abuse of notation we will also sometimes use $Q_{D}\br{X\br{I},x}$ as the set consisting of queries in sequence $Q_{D}\br{X\br{I},x}$. This is done in order to not inflate the amount of symbols and will not become problematic during the analysis of the solutions.
Whenever clear from the context, for the clarity of the analysis, we will occasionally drop any of the subscripts or arguments of the $\COST$ function.
We are now ready to define the \textit{Generalized Search Problem}:

\begin{tcolorbox}[colback=white, title=Generalized Search Problem, fonttitle=\bfseries, breakable]
\paragraph{Input:} Search space, restricitions on the query model and the optimization criterion
\paragraph{Output:} A viable decision tree for the input search space fulfilling all of the restrictions of the query model which optimizes the criterion.
\end{tcolorbox}