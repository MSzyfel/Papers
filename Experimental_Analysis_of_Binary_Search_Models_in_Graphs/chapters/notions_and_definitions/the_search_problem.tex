\section{The Search Problem}

Below we list the definitions regarding the search problem. We start with definitions of all viable search spaces and query models connected with them. Since the problem has a modular form and one can almost freely swap criteria and constraints, the number of separate variants is very large. Due to this we define all of the possible search spaces, query models and criteria separately and then we formulate the \textit{General Search Problem} based on the chosen variant.

\subsection{Search spaces with according query models}

The \textit{Tree Search Instance} consists of a pair $T=\br{V\br{T},E\br{T}}$. Among $V\br{T}$ there is a unique hidden target element $x$ which is required
to be located. During the \textit{Search Process} the searcher is allowed to iteratively perform a \textit{query} which asks about chosen vertex (or alternatively an edge $e$). If the answer is affirmative, then $v$ is the target, otherwise a connected component $H\in T-v$ is returned such that $x\in V\br
{H}$ (for the edge version always $H\in T-e$ is returned). Based on this information the searcher narrows the subtree of $T$ which might contain $x$ until there is only one possible option left.

The \textit{Graph Search Instance} consists of a pair $G=\br{V\br{G},E\br{G}}$. Among $V\br{G}$ there is a unique hidden target element $x$ which is required
to be located. During the \textit{Search Process} the searcher is allowed to iteratively perform a \textit{query} which asks about chosen vertex (or alternatively an edge $e$). If the answer is affirmative, then $v$ is the target, otherwise a connected component $H\in G-v$ is returned such that $x\in V\br
{H}$ (for the edge version always $H\in G-e$ is returned). Based on this information the searcher narrows the subgraph of $G$ which might contain $x$ until there is only one possible option left. 

\begin{remark}
    In the vertex query model we require that every vertex must be queried even when such vertex is the last among the candidate set. Note that it is sometimes assumed that in such case, this vertex does not need to be queried which may reduce the cost of the solution. Note that all of the algorithms showed in this work can be altered to take this assumption into account. For the sake of the brevity we do not include them but we encourage the reader to obtain them as an exercise.
\end{remark} 

The \textit{Poset Search Instance} consists of a pair $\mathcal{P}=\br{X, \preceq}$. Among $X$ there is a unique hidden target element $x$ which is required
to be located. During the \textit{Search Process} the searcher is allowed to iteratively perform a \textit{query} which asks about chosen element $v\in X$ and as the answers receives information whether $x\preceq v$. Based on this information the searcher narrows the subset of $X$ which might contain $x$ until there is only one possible option left.

The \textit{Binary Identification Problem Instance} consists of a pair $\mathcal{P}=\br{\mathcal{H}, \mathcal{Q}}$. In the \textit{Binary Identification Problem} we are given a pair $\br{\mathcal{H}, \mathcal{Q}}$ where $\mathcal{H}$ is a set of hypotheses and $\mathcal{Q}$ is a set of queries. Each query $q = \brc{R_1, R_2,...R_k}$ is a partition of $\mathcal{H}$ (we require that $\bigcup_{R\in q}R=\mathcal{H}$ and for any $R_1,R_2\in q$: $R_1\cap R_2=\emptyset$). Among $\mathcal{H}$ there is a unique hidden target hypothesis $x$ which is required
to be identified. During the \textit{Search Process} the searcher is allowed to iteratively perform a chosen query $q$. As the response the searcher obtains information which $R\in q$ contains the hidden target. Based on this information the searcher narrows the subset of $\mathcal{H}$ which might contain $x$ until there is only one possible option left.
\subsection{Additional input parameters}
As a part of the input we will also allow the cost function. Let $\mathcal{Q}$ be the space of possible queries. The cost of query $q\in\mathcal{Q}$ is then denoted
as $c:\mathcal{Q}\to \mathbb{R}^+$. We will also allow the weight function. Let $X$ be the space of the possible targets. The weight of query $x\in X$ is then denoted
as $w:X\to \mathbb{R}^+$. 
\subsection{Decision trees, optimization criteria and the Generalized Search Problem}
Let $I=\br{X\br{I}, \mathcal{Q}\br{I}}$ be an arbitrary search space and $c,w$ be the cost and weight functions. A decision tree is pair $D=(V\br{D}, E\br{D}, m)$ where $V\br{D}=X\br{I}$ are vertices and $E\br{D}$ are edges of $D$. 

It is required that each child of $q\in V\br{
D}$ corresponds to a distinct response to the query at $q$, with respect to the subset of candidate solutions that remain after performing all queries along the path $r\br{D}\circ P\br{r\br{D}, q}$. 

Let $Q_D\br{X\br{I},x}$ denote the sequence of queries made to locate a target $x \in X$ using $D$. We define the cost of searching for $x$ using $D$ in $\br{I,c}$ as:
$$
\COST_{max,D}\br{I, c, x} = \sum_{q\in Q_{D}\br{X\br{I},x}}c\br{q}
$$

We define the worst case cost of a decision tree $D$ in $I$ with weight function $w$ as:
$$
\COST_{avg, D}\br{I, w} = \max_{x\in X\br{I}} \brc{\COST_D\br{I, x}}
$$

By a slight abuse of notation we will also sometimes use $Q_{D}\br{X\br{I},x}$ as the set consisting of queries in sequence $Q_{D}\br{X\br{I},x}$. This is done in order to not inflate the amount of symbols and will not become problematic during the analysis of the solutions.
Whenever clear from the context, for the clarity of the analysis, we will occasionally drop any of the subscripts or arguments of the $\COST$ function.
We are now ready to define the \textit{Generalized Search Problem}:

\begin{tcolorbox}[colback=white, title=Generalized Search Problem, fonttitle=\bfseries, breakable]
\paragraph{Input:} Search space, restricitions on the query model and the optimization criterion
\paragraph{Output:} A viable decision tree for the input search space fulfilling all of the restrictions of the query model which optimizes the criterion.
\end{tcolorbox}